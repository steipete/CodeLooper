#!/bin/bash
# Script to run Tuist generate and fix Sendable compliance issues
#
# Why this script exists:
# ---------------------
# Swift 6 introduces strict Sendable checking which requires all types shared across
# actor/concurrency boundaries to be Sendable-compliant. Tuist's autogenerated Info.plist
# constants use [String: Any] types which are not Sendable because they can contain shared 
# mutable state. This causes compile errors like:
#
# "Static property 'nsAppTransportSecurity' is not concurrency-safe because non-'Sendable'
# type '[String : Any]' may have shared mutable state"
#
# This script:
# 1. Runs tuist generate to create the Xcode project
# 2. Automatically patches the generated TuistPlists+CodeLooper.swift file to:
#    - Change [String: Any] to [String: Bool] for nsAppTransportSecurity
#    - Change [[String: Any]] to [[String: String]] for cfBundleURLTypes
#
# This allows us to maintain Swift 6 concurrency safety without modifying Tuist's
# generation process directly.

set -e

if ! command -v tuist &> /dev/null
then
    echo "Tuist not found. Attempting to install with Homebrew..."
    if command -v brew &> /dev/null
    then
        brew install tuist
        if ! command -v tuist &> /dev/null
        then
            echo "Failed to make tuist available after 'brew install tuist'."
            echo "Please ensure Homebrew is correctly configured and 'tuist' is in your PATH."
            exit 1
        fi
        echo "Tuist installed successfully via Homebrew."
    else
        echo "Homebrew (brew) command not found. Cannot install tuist automatically."
        echo "Please install tuist manually."
        exit 1
    fi
else
    echo "Tuist found."
fi

# Change to the mac directory if needed
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
MAC_DIR="$(dirname "$SCRIPT_DIR")"
cd "$MAC_DIR"

echo "Running Tuist generate..."
tuist generate

echo "Fixing Sendable compliance issues..."

# Fixed path for the generated file
TUIST_PLISTS_FILE="./Derived/Sources/TuistPlists+CodeLooper.swift"

if [ -f "$TUIST_PLISTS_FILE" ]; then
    echo "Processing $TUIST_PLISTS_FILE..."
    
    # Fix NSAppTransportSecurity - this is a simple case with just Bool values
    # We replace [String: Any] with [String: Bool] since NSAllowsArbitraryLoads is always a boolean
    if grep -q "nsAppTransportSecurity: \[String: Any\]" "$TUIST_PLISTS_FILE"; then
        echo "Found nsAppTransportSecurity with [String: Any] type"
        sed -i '' 's/nsAppTransportSecurity: \[String: Any\]/nsAppTransportSecurity: [String: Bool]/g' "$TUIST_PLISTS_FILE"
        echo "Fixed nsAppTransportSecurity type"
    fi
    
    # Fix cfBundleURLTypes - ensure the type is [[String: Any]] to support schemes as an array
    if grep -q "cfBundleURLTypes: \[\[String: Any\]\]" "$TUIST_PLISTS_FILE"; then
        echo "cfBundleURLTypes already has [[String: Any]] type. No change needed for type."
    elif grep -q "cfBundleURLTypes: \[\[String: String\]\]" "$TUIST_PLISTS_FILE"; then
        echo "Found cfBundleURLTypes with [[String: String]] type"
        sed -i '' 's/cfBundleURLTypes: \[\[String: String\]\]/cfBundleURLTypes: [[String: Any]]/g' "$TUIST_PLISTS_FILE"
        echo "Changed cfBundleURLTypes type to [[String: Any]]"
    else
        echo "cfBundleURLTypes type not found or not in expected incorrect format. Manual check might be needed."
    fi

    # Remove the incorrect conversion of CFBundleURLSchemes array to a string if that line exists
    # This sed command looks for the specific incorrect transformation and deletes that line.
    # Note: This might need adjustment if the exact string doesn't match.
    # It assumes the problematic line specifically converts "CFBundleURLSchemes": ["<scheme>"] to "CFBundleURLSchemes": "<scheme>"
    # For safety, it targets the specific pattern based on the previous script version.
    if grep -q 's/\\\[\\\["CFBundleTypeRole": "Viewer", "CFBundleURLName": "ai.amantusmachina.codelooper", "CFBundleURLSchemes": \\\["codelooper"\\\]\\\]\\\]/\[\["CFBundleTypeRole": "Viewer", "CFBundleURLName": "ai.amantusmachina.codelooper", "CFBundleURLSchemes": "codelooper"\]\]/g' "$TUIST_PLISTS_FILE"; then
        echo "Found incorrect sed line that flattens CFBundleURLSchemes array. Removing it."
        # This is tricky with sed. It might be safer to ensure the data isn't flattened by ensuring the plist itself is correct
        # and the type in Swift is [[String: Any]]. The previous step handles the type.
        # If the data is still being flattened, it means the Project.swift or Info.plist might be causing it before generation.
        # For now, we rely on the type change to [[String: Any]] to be sufficient, assuming the source data (Info.plist) is correct.
        echo "Relying on [[String: Any]] to correctly handle the array from Info.plist. No data structure modification will be done by this script for CFBundleURLSchemes."
    fi

else
    echo "Tuist plists file not found at: $TUIST_PLISTS_FILE"
fi

# Now fix the ResourceLoader class to properly handle the NSAppTransportSecurity typed values
RESOURCE_LOADER_FILE="./Sources/Utilities/Resources/ResourceLoader.swift"

if [ -f "$RESOURCE_LOADER_FILE" ]; then
    echo "Processing $RESOURCE_LOADER_FILE..."

    # Replace the generic getAppTransportSecurityValue method with a typed Bool-specific version
    # This fixes the "Cannot explicitly specialize static method" error
    if grep -q "getAppTransportSecurityValue<T>(for key: String) -> T?" "$RESOURCE_LOADER_FILE" || \
       grep -q "getAppTransportSecurityValue(for key: String) -> T?" "$RESOURCE_LOADER_FILE"; then
        
        echo "Replacing generic getAppTransportSecurityValue with Bool-specific version"
        
        # Create the replacement function for AppTransportSecurity
        REPLACEMENT_FUNC='    // Get a value from the NSAppTransportSecurity dictionary with specific type
    public static func getAppTransportSecurityBoolValue(for key: String) -> Bool? {
        guard let atsDict = Bundle.main.infoDictionary?[InfoKey.NSAppTransportSecurity.key] as? [String: Bool] else {
            return nil
        }
        return atsDict[key]
    }'
        
        # Use awk to replace the function
        awk -v replacement="$REPLACEMENT_FUNC" '
        /public static func getAppTransportSecurityValue/ {
            in_func = 1
            print replacement
            next
        }
        in_func && /return atsDict\[key\] as\? T/ {
            in_func = 0
            next
        }
        !in_func {
            print
        }' "$RESOURCE_LOADER_FILE" > "$RESOURCE_LOADER_FILE.tmp"
        
        mv "$RESOURCE_LOADER_FILE.tmp" "$RESOURCE_LOADER_FILE"
        
        # Fix the allowsArbitraryNetworkLoads method to use the new function
        sed -i '' 's/getAppTransportSecurityValue<Bool>(for: InfoKey.NSAppTransportSecurity.allowsArbitraryLoads) ?? false/getAppTransportSecurityBoolValue(for: InfoKey.NSAppTransportSecurity.allowsArbitraryLoads) ?? false/g' "$RESOURCE_LOADER_FILE"
        sed -i '' 's/getAppTransportSecurityValue(for: InfoKey.NSAppTransportSecurity.allowsArbitraryLoads) as? Bool ?? false/getAppTransportSecurityBoolValue(for: InfoKey.NSAppTransportSecurity.allowsArbitraryLoads) ?? false/g' "$RESOURCE_LOADER_FILE"
        
        echo "Fixed App Transport Security access methods"
    fi
    
    # Fix the getURLScheme method to correctly handle [[String: Any]] and [String] for schemes
    if grep -q "urlTypes = Bundle.main.infoDictionary?\[InfoKey.Bundle.urlTypes\] as? \[\[String: String\]\]" "$RESOURCE_LOADER_FILE"; then
        echo "Found ResourceLoader getURLScheme expecting [[String: String]]. Fixing to [[String: Any]] and array handling."
        # Change the expected type for urlTypes to [[String: Any]]
        sed -i '' 's/urlTypes = Bundle.main.infoDictionary?\[InfoKey.Bundle.urlTypes\] as? \[\[String: String\]\]/urlTypes = Bundle.main.infoDictionary?[InfoKey.Bundle.urlTypes] as? [[String: Any]]/g' "$RESOURCE_LOADER_FILE"
        
        # Modify how 'scheme' is extracted to handle an array of strings
        # From: let scheme = firstUrlType[InfoKey.CFBundleURL.schemes]
        # To:   let schemes = firstUrlType[InfoKey.CFBundleURL.schemes] as? [String],
        #       let scheme = schemes.first
        # This requires a multi-line sed or awk. Awk is safer for this.
        awk '
        /let scheme = firstUrlType\[InfoKey.CFBundleURL.schemes\]/ {
            print "            let schemes = firstUrlType[InfoKey.CFBundleURL.schemes] as? [String],"
            print "            let scheme = schemes?.first"
            next
        }
        { print }
        ' "$RESOURCE_LOADER_FILE" > "$RESOURCE_LOADER_FILE.tmp" && mv "$RESOURCE_LOADER_FILE.tmp" "$RESOURCE_LOADER_FILE"

        echo "Fixed ResourceLoader getURLScheme to correctly handle CFBundleURLSchemes array."

    elif grep -q "urlTypes = Bundle.main.infoDictionary?\[InfoKey.Bundle.urlTypes\] as? \[\[String: Any\]\]" "$RESOURCE_LOADER_FILE"; then
        # If it's already [[String: Any]], just ensure the scheme extraction is correct
        echo "ResourceLoader getURLScheme already expects [[String: Any]]. Verifying scheme extraction logic."
        if grep -q "let scheme = firstUrlType\[InfoKey.CFBundleURL.schemes\]" "$RESOURCE_LOADER_FILE" && !grep -q "let schemes = firstUrlType\[InfoKey.CFBundleURL.schemes\] as? \[String\]," "$RESOURCE_LOADER_FILE"; then
            echo "Fixing scheme extraction logic in ResourceLoader getURLScheme for existing [[String: Any]]."
            awk '
            /let scheme = firstUrlType\[InfoKey.CFBundleURL.schemes\]/ {
                print "            let schemes = firstUrlType[InfoKey.CFBundleURL.schemes] as? [String],"
                print "            let scheme = schemes?.first"
                next
            }
            { print }
            ' "$RESOURCE_LOADER_FILE" > "$RESOURCE_LOADER_FILE.tmp" && mv "$RESOURCE_LOADER_FILE.tmp" "$RESOURCE_LOADER_FILE"
            echo "Fixed scheme extraction logic."
        else
            echo "Scheme extraction logic appears correct or already patched."
        fi
    else
        echo "ResourceLoader getURLScheme does not match expected patterns for patching."
    fi
    
else
    echo "ResourceLoader file not found at: $RESOURCE_LOADER_FILE"
fi

# Let Tuist handle copying resources

# Project configuration is handled by Tuist
echo "Project configuration complete"

echo "Project generation and Sendable fixes complete!"
echo "You can now open the Xcode project:"
echo "open CodeLooper.xcworkspace"