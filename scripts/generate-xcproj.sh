#!/bin/bash
# Script to run Tuist generate and fix Sendable compliance issues
#
# Why this script exists:
# ---------------------
# Swift 6 introduces strict Sendable checking which requires all types shared across
# actor/concurrency boundaries to be Sendable-compliant. Tuist's autogenerated Info.plist
# constants use [String: Any] types which are not Sendable because they can contain shared 
# mutable state. This causes compile errors like:
#
# "Static property 'nsAppTransportSecurity' is not concurrency-safe because non-'Sendable'
# type '[String : Any]' may have shared mutable state"
#
# This script:
# 1. Runs tuist generate to create the Xcode project
# 2. Automatically patches the generated TuistPlists+CodeLooper.swift file to:
#    - Change [String: Any] to [String: Bool] for nsAppTransportSecurity
#    - Change [[String: Any]] to [[String: String]] for cfBundleURLTypes
#
# This allows us to maintain Swift 6 concurrency safety without modifying Tuist's
# generation process directly.

set -e

# Quit Xcode before regenerating
echo "Attempting to quit Xcode..."
osascript -e 'tell application "Xcode" to quit saving no'
echo "Xcode quit command sent. Continuing with script..."

# Check if mise is available and activate it
if command -v mise &> /dev/null; then
    echo "mise found, activating environment..."
    eval "$(mise activate bash)"
elif [ -f "$HOME/.local/bin/mise" ]; then
    echo "mise found at $HOME/.local/bin/mise, adding to PATH and activating..."
    export PATH="$HOME/.local/bin:$PATH"
    eval "$(mise activate bash)"
fi

# Check if tuist is available (might be installed via mise now)
if ! command -v tuist &> /dev/null; then
    # If mise is available, try to install tuist via mise
    if command -v mise &> /dev/null; then
        echo "Tuist not found. Installing via mise..."
        mise install
        eval "$(mise activate bash)"
        
        if ! command -v tuist &> /dev/null; then
            echo "Failed to install tuist via mise. Falling back to Homebrew..."
            if command -v brew &> /dev/null; then
                brew install tuist
            else
                echo "Neither mise nor Homebrew available. Cannot install tuist automatically."
                echo "Please install tuist manually."
                exit 1
            fi
        fi
    else
        # Fall back to Homebrew if mise is not available
        echo "Tuist not found. Attempting to install with Homebrew..."
        if command -v brew &> /dev/null; then
            brew install tuist
            if ! command -v tuist &> /dev/null; then
                echo "Failed to make tuist available after 'brew install tuist'."
                echo "Please ensure Homebrew is correctly configured and 'tuist' is in your PATH."
                exit 1
            fi
            echo "Tuist installed successfully via Homebrew."
        else
            echo "Neither mise nor Homebrew available. Cannot install tuist automatically."
            echo "Please install tuist manually."
            exit 1
        fi
    fi
else
    echo "Tuist found at: $(which tuist)"
    tuist version
fi

# Change to the mac directory if needed
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
MAC_DIR="$(dirname "$SCRIPT_DIR")"
cd "$MAC_DIR"

echo "Running Tuist generate..."
tuist generate

echo "Fixing Sendable compliance issues..."

# Fixed path for the generated file
TUIST_PLISTS_FILE="./Derived/Sources/TuistPlists+CodeLooper.swift"

if [ -f "$TUIST_PLISTS_FILE" ]; then
    echo "Processing $TUIST_PLISTS_FILE..."
    
    # Fix NSAppTransportSecurity - this is a simple case with just Bool values
    # We replace [String: Any] with [String: Bool] since NSAllowsArbitraryLoads is always a boolean
    if grep -q "nsAppTransportSecurity: \[String: Any\]" "$TUIST_PLISTS_FILE"; then
        echo "Found nsAppTransportSecurity with [String: Any] type"
        sed -i '' 's/nsAppTransportSecurity: \[String: Any\]/nsAppTransportSecurity: [String: Bool]/g' "$TUIST_PLISTS_FILE"
        echo "Fixed nsAppTransportSecurity type"
    fi
    
    # Fix cfBundleURLTypes - change from [[String: Any]] to a Sendable-compliant type
    # Since we know the exact structure, we can make it more type-safe
    if grep -q "cfBundleURLTypes: \[\[String: Any\]\]" "$TUIST_PLISTS_FILE"; then
        echo "Found cfBundleURLTypes with [[String: Any]] type. Converting to Sendable type."
        # Replace the type and convert the array value to use proper typing
        sed -i '' 's/cfBundleURLTypes: \[\[String: Any\]\] = \[\["CFBundleTypeRole": "Viewer", "CFBundleURLName": "me\.steipete\.codelooper", "CFBundleURLSchemes": \["codelooper"\]\]\]/cfBundleURLTypes: [[String: Sendable]] = [["CFBundleTypeRole": "Viewer", "CFBundleURLName": "me.steipete.codelooper", "CFBundleURLSchemes": ["codelooper"]]]/g' "$TUIST_PLISTS_FILE"
        echo "Changed cfBundleURLTypes to use [[String: Sendable]] type"
    elif grep -q "cfBundleURLTypes: \[\[String: String\]\]" "$TUIST_PLISTS_FILE"; then
        echo "Found cfBundleURLTypes with [[String: String]] type"
        sed -i '' 's/cfBundleURLTypes: \[\[String: String\]\]/cfBundleURLTypes: [[String: Sendable]]/g' "$TUIST_PLISTS_FILE"
        echo "Changed cfBundleURLTypes type to [[String: Sendable]]"
    else
        echo "cfBundleURLTypes type not found or not in expected incorrect format. Manual check might be needed."
    fi

    # Remove the incorrect conversion of CFBundleURLSchemes array to a string if that line exists
    # This sed command looks for the specific incorrect transformation and deletes that line.
    # Note: This might need adjustment if the exact string doesn't match.
    # It assumes the problematic line specifically converts "CFBundleURLSchemes": ["<scheme>"] to "CFBundleURLSchemes": "<scheme>"
    # For safety, it targets the specific pattern based on the previous script version.
    if grep -q 's/\\\[\\\["CFBundleTypeRole": "Viewer", "CFBundleURLName": "me.steipete.codelooper", "CFBundleURLSchemes": \\\["codelooper"\\\]\\\]\\\]/\[\["CFBundleTypeRole": "Viewer", "CFBundleURLName": "me.steipete.codelooper", "CFBundleURLSchemes": "codelooper"\]\]/g' "$TUIST_PLISTS_FILE"; then
        echo "Found incorrect sed line that flattens CFBundleURLSchemes array. Removing it."
        # This is tricky with sed. It might be safer to ensure the data isn't flattened by ensuring the plist itself is correct
        # and the type in Swift is [[String: Any]]. The previous step handles the type.
        # If the data is still being flattened, it means the Project.swift or Info.plist might be causing it before generation.
        # For now, we rely on the type change to [[String: Any]] to be sufficient, assuming the source data (Info.plist) is correct.
        echo "Relying on [[String: Any]] to correctly handle the array from Info.plist. No data structure modification will be done by this script for CFBundleURLSchemes."
    fi

else
    echo "Tuist plists file not found at: $TUIST_PLISTS_FILE"
fi

# Now fix the ResourceLoader class to properly handle the NSAppTransportSecurity typed values
RESOURCE_LOADER_FILE="./Core/Utilities/Helpers/ResourceLoader.swift"

if [ -f "$RESOURCE_LOADER_FILE" ]; then
    echo "Processing $RESOURCE_LOADER_FILE..."

    # Replace the generic getAppTransportSecurityValue method with a typed Bool-specific version
    # This fixes the "Cannot explicitly specialize static method" error
    if grep -q "getAppTransportSecurityValue<T>(for key: String) -> T?" "$RESOURCE_LOADER_FILE" || \
       grep -q "getAppTransportSecurityValue(for key: String) -> T?" "$RESOURCE_LOADER_FILE"; then
        
        echo "Replacing generic getAppTransportSecurityValue with Bool-specific version"
        
        # Create the replacement function for AppTransportSecurity
        REPLACEMENT_FUNC='    // Get a value from the NSAppTransportSecurity dictionary with specific type
    public static func getAppTransportSecurityBoolValue(for key: String) -> Bool? {
        guard let atsDict = Bundle.main.infoDictionary?[InfoKey.NSAppTransportSecurity.key] as? [String: Bool] else {
            return nil
        }
        return atsDict[key]
    }'
        
        # Use awk to replace the function
        awk -v replacement="$REPLACEMENT_FUNC" '
        /public static func getAppTransportSecurityValue/ {
            in_func = 1
            print replacement
            next
        }
        in_func && /return atsDict\[key\] as\? T/ {
            in_func = 0
            next
        }
        !in_func {
            print
        }' "$RESOURCE_LOADER_FILE" > "$RESOURCE_LOADER_FILE.tmp"
        
        mv "$RESOURCE_LOADER_FILE.tmp" "$RESOURCE_LOADER_FILE"
        
        # Fix the allowsArbitraryNetworkLoads method to use the new function
        sed -i '' 's/getAppTransportSecurityValue<Bool>(for: InfoKey.NSAppTransportSecurity.allowsArbitraryLoads) ?? false/getAppTransportSecurityBoolValue(for: InfoKey.NSAppTransportSecurity.allowsArbitraryLoads) ?? false/g' "$RESOURCE_LOADER_FILE"
        sed -i '' 's/getAppTransportSecurityValue(for: InfoKey.NSAppTransportSecurity.allowsArbitraryLoads) as? Bool ?? false/getAppTransportSecurityBoolValue(for: InfoKey.NSAppTransportSecurity.allowsArbitraryLoads) ?? false/g' "$RESOURCE_LOADER_FILE"
        
        echo "Fixed App Transport Security access methods"
    fi
    
    # Fix the getURLScheme method to correctly handle [[String: Sendable]] and [String] for schemes
    if grep -q "urlTypes = Bundle.main.infoDictionary?\[InfoKey.Bundle.urlTypes\] as? \[\[String: String\]\]" "$RESOURCE_LOADER_FILE"; then
        echo "Found ResourceLoader getURLScheme expecting [[String: String]]. Fixing to [[String: Sendable]] and array handling."
        # Change the expected type for urlTypes to [[String: Sendable]]
        sed -i '' 's/urlTypes = Bundle.main.infoDictionary?\[InfoKey.Bundle.urlTypes\] as? \[\[String: String\]\]/urlTypes = Bundle.main.infoDictionary?[InfoKey.Bundle.urlTypes] as? [[String: Sendable]]/g' "$RESOURCE_LOADER_FILE"
        
        # Modify how 'scheme' is extracted to handle an array of strings
        # From: let scheme = firstUrlType[InfoKey.CFBundleURL.schemes]
        # To:   let schemes = firstUrlType[InfoKey.CFBundleURL.schemes] as? [String],
        #       let scheme = schemes.first
        # This requires a multi-line sed or awk. Awk is safer for this.
        awk '
        /let scheme = firstUrlType\[InfoKey.CFBundleURL.schemes\]/ {
            print "            let schemes = firstUrlType[InfoKey.CFBundleURL.schemes] as? [String],"
            print "            let scheme = schemes?.first"
            next
        }
        { print }
        ' "$RESOURCE_LOADER_FILE" > "$RESOURCE_LOADER_FILE.tmp" && mv "$RESOURCE_LOADER_FILE.tmp" "$RESOURCE_LOADER_FILE"

        echo "Fixed ResourceLoader getURLScheme to correctly handle CFBundleURLSchemes array."

    elif grep -q "urlTypes = Bundle.main.infoDictionary?\[InfoKey.Bundle.urlTypes\] as? \[\[String: Any\]\]" "$RESOURCE_LOADER_FILE"; then
        # If it's [[String: Any]], change to [[String: Sendable]] and ensure scheme extraction is correct
        echo "Found ResourceLoader getURLScheme expecting [[String: Any]]. Fixing to [[String: Sendable]] and verifying scheme extraction logic."
        sed -i '' 's/urlTypes = Bundle.main.infoDictionary?\[InfoKey.Bundle.urlTypes\] as? \[\[String: Any\]\]/urlTypes = Bundle.main.infoDictionary?[InfoKey.Bundle.urlTypes] as? [[String: Sendable]]/g' "$RESOURCE_LOADER_FILE"
        if grep -q "let scheme = firstUrlType\[InfoKey.CFBundleURL.schemes\]" "$RESOURCE_LOADER_FILE" && !grep -q "let schemes = firstUrlType\[InfoKey.CFBundleURL.schemes\] as? \[String\]," "$RESOURCE_LOADER_FILE"; then
            echo "Fixing scheme extraction logic in ResourceLoader getURLScheme for existing [[String: Any]]."
            awk '
            /let scheme = firstUrlType\[InfoKey.CFBundleURL.schemes\]/ {
                print "            let schemes = firstUrlType[InfoKey.CFBundleURL.schemes] as? [String],"
                print "            let scheme = schemes?.first"
                next
            }
            { print }
            ' "$RESOURCE_LOADER_FILE" > "$RESOURCE_LOADER_FILE.tmp" && mv "$RESOURCE_LOADER_FILE.tmp" "$RESOURCE_LOADER_FILE"
            echo "Fixed scheme extraction logic."
        else
            echo "Scheme extraction logic appears correct or already patched."
        fi
    elif grep -q "urlTypes = Bundle.main.infoDictionary?\[InfoKey.Bundle.urlTypes\] as? \[\[String: Sendable\]\]" "$RESOURCE_LOADER_FILE"; then
        # If it's already [[String: Sendable]], just ensure the scheme extraction is correct
        echo "ResourceLoader getURLScheme already expects [[String: Sendable]]. Verifying scheme extraction logic."
        if grep -q "let scheme = firstUrlType\[InfoKey.CFBundleURL.schemes\]" "$RESOURCE_LOADER_FILE" && !grep -q "let schemes = firstUrlType\[InfoKey.CFBundleURL.schemes\] as? \[String\]," "$RESOURCE_LOADER_FILE"; then
            echo "Fixing scheme extraction logic in ResourceLoader getURLScheme for existing [[String: Sendable]]."
            awk '
            /let scheme = firstUrlType\[InfoKey.CFBundleURL.schemes\]/ {
                print "            let schemes = firstUrlType[InfoKey.CFBundleURL.schemes] as? [String],"
                print "            let scheme = schemes?.first"
                next
            }
            { print }
            ' "$RESOURCE_LOADER_FILE" > "$RESOURCE_LOADER_FILE.tmp" && mv "$RESOURCE_LOADER_FILE.tmp" "$RESOURCE_LOADER_FILE"
            echo "Fixed scheme extraction logic."
        else
            echo "Scheme extraction logic appears correct or already patched."
        fi
    else
        echo "ResourceLoader getURLScheme does not match expected patterns for patching."
    fi
    
else
    echo "ResourceLoader file not found at: $RESOURCE_LOADER_FILE"
fi

# Let Tuist handle copying resources

# Project configuration is handled by Tuist
echo "Project configuration complete"

echo "Fixing SwiftFormat issues in generated files..."

# Fix TuistBundle files missing final newlines
for file in "./Derived/Sources/TuistBundle+CodeLooper.swift" "./Derived/Sources/TuistBundle+CodeLooperTests.swift"; do
    if [ -f "$file" ]; then
        echo "Fixing formatting in $file"
        # Simple approach: just add a newline if file doesn't end with one
        if [ -n "$(tail -c 1 "$file")" ]; then
            echo >> "$file"
        fi
    fi
done

# Fix brace formatting in SoundEngine.swift  
SOUND_ENGINE_FILE="./Core/Utilities/Helpers/SoundEngine.swift"
if [ -f "$SOUND_ENGINE_FILE" ]; then
    echo "Fixing brace formatting in $SOUND_ENGINE_FILE"
    # Fix the specific brace issue at line 103 - move opening brace to previous line
    sed -i '' '/== noErr$/{
        N
        s/== noErr\n        {/== noErr {/
    }' "$SOUND_ENGINE_FILE"
fi

# Fix indentation issues in other files by running swiftformat on specific problem files
# Skip WindowAIDiagnosticsManager.swift since it has issues with indent/wrap rules
SWIFTFORMAT_FILES=(
    "./Features/AIAnalysis/Domain/Services/ScreenshotAnalyzer.swift"
    "./Features/Monitoring/Domain/Services/ProcessMonitorService.swift" 
    "./Features/Monitoring/Domain/Models/MonitoredInstanceInfo.swift"
)

for file in "${SWIFTFORMAT_FILES[@]}"; do
    if [ -f "$file" ]; then
        echo "Running SwiftFormat on $file to fix indentation"
        # Run swiftformat with specific rules that commonly cause issues
        if command -v swiftformat &> /dev/null; then
            swiftformat "$file" --rules indent,braces --quiet
        else
            echo "SwiftFormat not available, skipping formatting fix for $file"
        fi
    fi
done

# Handle WindowAIDiagnosticsManager.swift separately with safer rules
WINDOWAI_FILE="./Features/AIAnalysis/Domain/Services/WindowAIDiagnosticsManager.swift"
if [ -f "$WINDOWAI_FILE" ]; then
    echo "Running SwiftFormat on $WINDOWAI_FILE with safe rules"
    if command -v swiftformat &> /dev/null; then
        # Only apply braces rule to avoid the infinite loop issue with indent/wrap
        swiftformat "$WINDOWAI_FILE" --rules braces --quiet
    fi
fi

# Fix specific SwiftFormat issues in other files
echo "Fixing specific SwiftFormat issues in AXpector files..."

# Fix AXpectorViewModel+Filtering.swift indentation issues
FILTERING_FILE="./AXpector/Sources/AXpector/ViewModelExtensions/AXpectorViewModel+Filtering.swift"
if [ -f "$FILTERING_FILE" ]; then
    echo "Running SwiftFormat on $FILTERING_FILE with conservative rules"
    if command -v swiftformat &> /dev/null; then
        swiftformat "$FILTERING_FILE" --rules braces,trailingSpace,wrapMultilineStatementBraces --quiet
    fi
fi

# Fix AXpectorViewModel+FocusTracking.swift brace issues
FOCUS_FILE="./AXpector/Sources/AXpector/ViewModelExtensions/AXpectorViewModel+FocusTracking.swift"
if [ -f "$FOCUS_FILE" ]; then
    echo "Running SwiftFormat on $FOCUS_FILE with conservative rules"
    if command -v swiftformat &> /dev/null; then
        swiftformat "$FOCUS_FILE" --rules braces,trailingSpace,wrapMultilineStatementBraces --quiet
    fi
fi

# Fix AXpectorViewModel+Highlighting.swift trailing space
HIGHLIGHTING_FILE="./AXpector/Sources/AXpector/ViewModelExtensions/AXpectorViewModel+Highlighting.swift"
if [ -f "$HIGHLIGHTING_FILE" ]; then
    echo "Running SwiftFormat on $HIGHLIGHTING_FILE with conservative rules"
    if command -v swiftformat &> /dev/null; then
        swiftformat "$HIGHLIGHTING_FILE" --rules trailingSpace --quiet
    fi
fi

# Fix CursorInputWatcherViewModel.swift trailing space
WATCHER_FILE="./Features/Monitoring/Domain/Services/CursorInputWatcherViewModel.swift"
if [ -f "$WATCHER_FILE" ]; then
    echo "Running SwiftFormat on $WATCHER_FILE with conservative rules"
    if command -v swiftformat &> /dev/null; then
        swiftformat "$WATCHER_FILE" --rules trailingSpace --quiet
    fi
fi

echo "Project generation, Sendable fixes, and SwiftFormat fixes complete!"
echo "You can now open the Xcode project:"
echo "open CodeLooper.xcworkspace"