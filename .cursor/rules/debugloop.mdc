---
description: 
globs: 
alwaysApply: false
---
# AXorcist Debugging: Finding the Cursor AI Slash Input Field

This document summarizes the debugging process used to locate a specific UI element (the AI slash input field) in the "Cursor" application (`com.todesktop.230313mzl4w4u92`) using `axorc`.

## Goal

The primary goal was to programmatically find the coordinates and read the text of the AI slash input field within the Cursor application. The key identifier for this field was its `AXDOMClassList` attribute, which was known to contain `"aislash-editor-input"`.

## Initial Challenges & Learnings

1.  **`kAXDOMClassListAttribute`**: This constant needed to be added to `AXorcist/Sources/AXorcist/Core/AccessibilityConstants.swift` to be usable in queries.
2.  **`AXElementMatcher.swift` Modification**: The matching logic in `AXorcist/Sources/AXorcist/Search/PathNavigator.swift` (specifically `elementMatchesAllCriteria`) was updated to handle `AXDOMClassListAttribute` with "contains" logic for arrays of strings or space-separated strings.
3.  **Build & Execution**:
    *   Initial attempts to run `axorc` via `mcp_terminator_execute` failed.
    *   Switching to `run_terminal_cmd` allowed successful builds (`swift package clean && swift build --product axorc` in the `AXorcist` directory) and execution.
    *   Query input files (e.g., `query_cursor_input.json`) must exist at the specified path.
4.  **Query Refinement - "Element not found"**:
    *   Early queries directly targeting `AXDOMClassList` containing `"aislash-editor-input"` failed, even with increased `max_depth`.
    *   Simplifying the query to fetch basic attributes of the application element (`"criteria": []`) helped confirm `axorc` could access the application.
    *   Targeting broader elements like `AXScrollArea` also failed, indicating an incorrect assumption about the UI hierarchy or role.
    *   Targeting `AXGroup` was partially successful but didn't immediately reveal the target.

## Breakthrough: UI Tree Dumping and Analysis

The key breakthrough came from dumping a wider section of the UI tree to a file for manual analysis.

1.  **Query to Dump "RootView" Children**:
    *   A query was crafted to find an `AXGroup` element whose `AXDOMClassList` contained `"RootView"`.
    *   `attributes_to_fetch` and `fetch_children_attributes` were set to `"all"`.
    *   `max_depth` was set to `15`.
    *   `debugLogging` was set to `true`.
    *   The output was redirected to a file: `./AXorcist/.build/debug/axorc --file query_cursor_input.json > axorc_rootview_dump.json`

    The `query_cursor_input.json` for this was:
    ```json
    {
      "command_id": "cursor-input-dump-rootview-children-to-file-001",
      "command": "query",
      "application": "com.todesktop.230313mzl4w4u92",
      "locator": {
        "criteria": [
          {
            "attribute": "AXDOMClassList",
            "value": "RootView",
            "match_type": "contains"
          }
        ]
      },
      "attributes_to_fetch": "all",
      "fetch_children_attributes": "all",
      "max_depth": 15,
      "debugLogging": true
    }
    ```

2.  **Analyzing `axorc_rootview_dump.json`**:
    *   The extensive `debugLogs` array in the output JSON was crucial.
    *   By tracing the `[_Traverse Entry] Visiting Role: ... at depth X` messages and associated `SearchCrit/DOMClass` logs, the hierarchy and `AXDOMClassList` attributes of nested elements were identified.

## Identifying the Target Element

The analysis of the dump file revealed the following path to the target element:

*   `AXWindow`
    *   `AXGroup` (AXDOMClassList: `("RootView")`)
        *   `AXGroup` (AXDOMClassList: `("CodeMirror", "cm-s-cursor-theme")`)
            *   `AXGroup` (AXDOMClassList: `("cm-scroller")`)
                *   `AXGroup` (AXDOMClassList: `("cm-content", "cm-ai-mode", "cm-ai-mode-background")`)
                    *   **`AXTextArea` (AXDOMClassList: `("aislash-editor-input")`)** <-- This is the target!

## Final Successful Query

Based on these findings, a targeted query successfully retrieved the element's details:

```json
{
  "command_id": "cursor-input-find-aislash-textarea-001",
  "command": "query",
  "application": "com.todesktop.230313mzl4w4u92",
  "locator": {
    "criteria": [
      {
        "attribute": "AXRole",
        "value": "AXTextArea"
      },
      {
        "attribute": "AXDOMClassList",
        "value": "aislash-editor-input",
        "match_type": "contains"
      }
    ]
  },
  "attributes_to_fetch": [
    "AXValue",
    "AXPosition",
    "AXSize",
    "AXRole",
    "AXRoleDescription",
    "AXIdentifier",
    "AXDOMClassList",
    "AXPath"
  ],
  "fetch_children_attributes": "none",
  "max_depth": 25,
  "debugLogging": true
}
```

## Key Retrieved Attributes for the Target Element

*   **`AXRole`**: `"AXTextArea"`
*   **`AXDOMClassList`**: `["aislash-editor-input"]`
*   **`AXValue`**: The current text content of the input field (e.g., `"2 and 3"`).
*   **`AXPosition`**: e.g., `{ "x": 1226, "y": 1575 }` (top-left coordinates).
*   **`AXSize`**: e.g., `{ "height": 18, "width": 1845 }`.
*   **`AXPath`**: `"Path (depth 6): AXApplication -> AXWindow -> AXGroup -> AXGroup -> AXGroup -> AXGroup -> AXTextArea"`

## Conclusion

This iterative process of refining queries, dealing with tool execution, and especially using broad, verbose dumps for offline analysis was key to successfully identifying and targeting the desired UI element. The `debugLogging: true` feature of `axorc` combined with output redirection is invaluable for complex UI hierarchies.

